import{k as A,t as l}from"./Kudn4uhO.js";import{n as p}from"./BNLZGSLr.js";import{d as i,w as f}from"./CikeeQrg.js";function _(r,s,n,a){var c=r.__style;if(p||c!==s){var h=A(s);(!p||h!==r.getAttribute("style"))&&(h==null?r.removeAttribute("style"):r.style.cssText=h),r.__style=s}return a}class M{ws=null;config;handlers=new Map;reconnectTimer=null;reconnectAttempts=0;intentionalDisconnect=!1;status;lastMessage;error;constructor(s={}){const n=typeof window<"u"?`${window.location.protocol==="https:"?"wss":"ws"}://${window.location.host}/api/ws`:"ws://localhost:8484/api/ws";this.config={url:s.url||n,reconnectDelay:s.reconnectDelay||5e3,maxReconnectAttempts:s.maxReconnectAttempts||10,debug:s.debug??!0},this.status=f("disconnected"),this.lastMessage=f(null),this.error=f(null)}connect(){if(this.ws?.readyState===WebSocket.OPEN){this.log("Already connected");return}this.intentionalDisconnect=!1,this.status.set("connecting"),this.error.set(null);try{this.log(`Connecting to ${this.config.url}...`),this.ws=new WebSocket(this.config.url),this.ws.onopen=this.handleOpen.bind(this),this.ws.onmessage=this.handleMessage.bind(this),this.ws.onerror=this.handleError.bind(this),this.ws.onclose=this.handleClose.bind(this)}catch(s){this.log("Connection error:",s),this.status.set("error"),this.error.set(s instanceof Error?s.message:"Connection failed"),this.scheduleReconnect()}}disconnect(){this.log("Disconnecting..."),this.intentionalDisconnect=!0,this.clearReconnectTimer(),this.ws&&(this.ws.close(),this.ws=null),this.status.set("disconnected")}on(s,n){this.handlers.has(s)||this.handlers.set(s,[]),this.handlers.get(s).push(n),this.log(`Registered handler for ${s}`)}off(s,n){const a=this.handlers.get(s);if(a){const c=a.indexOf(n);c>-1&&(a.splice(c,1),this.log(`Unregistered handler for ${s}`))}}send(s){this.ws?.readyState===WebSocket.OPEN?(this.ws.send(JSON.stringify(s)),this.log("Sent message:",s)):this.log("Cannot send message: not connected")}handleOpen(){this.log("âœ… Connected to WebSocket"),this.status.set("connected"),this.error.set(null),this.reconnectAttempts=0}handleMessage(s){try{const n=JSON.parse(s.data);this.log("ðŸ“¨ Received:",n.type,n),this.lastMessage.set(n);const a=this.handlers.get(n.type);a&&a.length>0?a.forEach(c=>{try{c(n)}catch(h){this.log(`Error in handler for ${n.type}:`,h)}}):this.log(`No handlers registered for ${n.type}`)}catch(n){this.log("Failed to parse message:",n),this.error.set("Invalid message received")}}handleError(s){this.log("âŒ WebSocket error:",s),this.status.set("error"),this.error.set("WebSocket connection error")}handleClose(s){this.log(`ðŸ”Œ Disconnected (code: ${s.code}, reason: ${s.reason})`),this.status.set("disconnected"),this.ws=null,this.intentionalDisconnect||this.scheduleReconnect()}scheduleReconnect(){if(this.reconnectAttempts>=this.config.maxReconnectAttempts){this.log(`Max reconnect attempts (${this.config.maxReconnectAttempts}) reached`),this.error.set("Failed to reconnect after multiple attempts");return}this.clearReconnectTimer();const s=this.config.reconnectDelay*Math.pow(1.5,this.reconnectAttempts);this.reconnectAttempts++,this.log(`Reconnecting in ${s}ms (attempt ${this.reconnectAttempts})...`),this.reconnectTimer=window.setTimeout(()=>{this.connect()},s)}clearReconnectTimer(){this.reconnectTimer!==null&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null)}log(...s){this.config.debug&&console.log("[WebSocket]",...s)}get isConnected(){return this.ws?.readyState===WebSocket.OPEN}}const w=new M;i(w.status,r=>r==="connected");const C=i(w.status,r=>{switch(r){case"connected":return{text:"Connected",color:"green",icon:"ðŸŸ¢"};case"connecting":return{text:"Connecting...",color:"yellow",icon:"ðŸŸ¡"};case"disconnected":return{text:"Disconnected",color:"gray",icon:"âšª"};case"error":return{text:"Error",color:"red",icon:"ðŸ”´"};default:return{text:"Unknown",color:"gray",icon:"âšª"}}});function P(){const r={downloads:new Map,stats:{active_downloads:0,queued:0,completed:0,failed:0,total_speed:0},loading:!1,error:null},{subscribe:s,set:n,update:a}=f(r),c="/api";async function h(){a(t=>({...t,loading:!0,error:null}));try{const t=await fetch(`${c}/downloads`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json(),o=new Map;e.downloads.forEach(d=>{o.set(d.id,d)}),a(d=>({...d,downloads:o,stats:e.stats,loading:!1})),console.log("[DownloadStore] Fetched",o.size,"downloads")}catch(t){const e=t instanceof Error?t.message:"Failed to fetch downloads";console.error("[DownloadStore] Fetch error:",e),a(o=>({...o,loading:!1,error:e}))}}async function D(t){try{const e=await fetch(`${c}/downloads`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}),o=await e.json();if(!e.ok)throw new Error(o.error||o.message||`HTTP ${e.status}`);return console.log("[DownloadStore] Added download:",o.task_id),l.success(`Download added: ${o.filename}`),{success:!0,data:o}}catch(e){const o=e instanceof Error?e.message:"Failed to add download";return console.error("[DownloadStore] Add error:",o),l.error(`Failed to add download: ${o}`),{success:!1,error:o}}}async function m(t){try{const e=await fetch(`${c}/downloads/${t}/pause`,{method:"POST"});if(!e.ok){const o=await e.json();throw new Error(o.error||`HTTP ${e.status}`)}return console.log("[DownloadStore] Paused download:",t),l.info("Download paused"),{success:!0}}catch(e){const o=e instanceof Error?e.message:"Failed to pause download";return console.error("[DownloadStore] Pause error:",o),l.error(`Failed to pause: ${o}`),{success:!1,error:o}}}async function S(t){try{const e=await fetch(`${c}/downloads/${t}/resume`,{method:"POST"});if(!e.ok){const o=await e.json();throw new Error(o.error||`HTTP ${e.status}`)}return console.log("[DownloadStore] Resumed download:",t),l.success("Download resumed"),{success:!0}}catch(e){const o=e instanceof Error?e.message:"Failed to resume download";return console.error("[DownloadStore] Resume error:",o),l.error(`Failed to resume: ${o}`),{success:!1,error:o}}}async function $(t){try{const e=await fetch(`${c}/downloads/${t}`,{method:"DELETE"});if(!e.ok){const o=await e.json();throw new Error(o.error||`HTTP ${e.status}`)}return a(o=>{const d=new Map(o.downloads);return d.delete(t),{...o,downloads:d}}),console.log("[DownloadStore] Deleted download:",t),l.info("Download deleted"),{success:!0}}catch(e){const o=e instanceof Error?e.message:"Failed to delete download";return console.error("[DownloadStore] Delete error:",o),l.error(`Failed to delete: ${o}`),{success:!1,error:o}}}async function y(t){try{const e=await fetch(`${c}/downloads/${t}/retry`,{method:"POST"});if(!e.ok){const o=await e.json();throw new Error(o.error||`HTTP ${e.status}`)}return console.log("[DownloadStore] Retrying download:",t),l.success("Download retry initiated"),{success:!0}}catch(e){const o=e instanceof Error?e.message:"Failed to retry download";return console.error("[DownloadStore] Retry error:",o),l.error(`Failed to retry: ${o}`),{success:!1,error:o}}}async function T(){try{const t=await fetch(`${c}/downloads/pause-all`,{method:"POST"}),e=await t.json();if(!t.ok)throw new Error(e.error||`HTTP ${t.status}`);return console.log("[DownloadStore] Paused all downloads:",e.affected),l.info(`Paused ${e.affected} download${e.affected!==1?"s":""}`),{success:!0,data:e}}catch(t){const e=t instanceof Error?t.message:"Failed to pause all downloads";return console.error("[DownloadStore] Pause all error:",e),l.error(`Failed to pause all: ${e}`),{success:!1,error:e}}}async function E(){try{const t=await fetch(`${c}/downloads/resume-all`,{method:"POST"}),e=await t.json();if(!t.ok)throw new Error(e.error||`HTTP ${t.status}`);return console.log("[DownloadStore] Resumed all downloads:",e.affected),l.success(`Resumed ${e.affected} download${e.affected!==1?"s":""}`),{success:!0,data:e}}catch(t){const e=t instanceof Error?t.message:"Failed to resume all downloads";return console.error("[DownloadStore] Resume all error:",e),l.error(`Failed to resume all: ${e}`),{success:!1,error:e}}}function k(){w.on("SYNC_ALL",t=>{if(console.log("[DownloadStore] SYNC_ALL received:",t.tasks?.length||0,"tasks"),t.tasks&&Array.isArray(t.tasks)){const e=new Map;t.tasks.forEach(o=>{e.set(o.id,o)}),a(o=>({...o,downloads:e}))}}),w.on("TASK_ADDED",t=>{console.log("[DownloadStore] TASK_ADDED:",t.task?.id),t.task&&a(e=>{const o=new Map(e.downloads);return o.set(t.task.id,t.task),{...e,downloads:o}})}),w.on("TASK_UPDATED",t=>{t.task&&t.task.id&&a(e=>{const o=new Map(e.downloads),d=o.get(t.task.id);return d?o.set(t.task.id,{...d,...t.task}):o.set(t.task.id,t.task),{...e,downloads:o}})}),w.on("TASK_REMOVED",t=>{console.log("[DownloadStore] TASK_REMOVED:",t.task_id),t.task_id&&a(e=>{const o=new Map(e.downloads);return o.delete(t.task_id),{...e,downloads:o}})}),w.on("ENGINE_STATS",t=>{t.stats&&a(e=>({...e,stats:t.stats}))}),console.log("[DownloadStore] WebSocket handlers initialized")}return{subscribe:s,fetchAll:h,addDownload:D,pauseDownload:m,resumeDownload:S,deleteDownload:$,retryDownload:y,pauseAll:T,resumeAll:E,initWebSocket:k}}const g=P(),u=i(g,r=>Array.from(r.downloads.values()).sort((s,n)=>new Date(n.created_at).getTime()-new Date(s.created_at).getTime())),x=i(u,r=>r.filter(s=>s.state==="DOWNLOADING"||s.state==="STARTING")),N=i(u,r=>r.filter(s=>s.state==="QUEUED")),W=i(u,r=>r.filter(s=>s.state==="COMPLETED")),j=i(u,r=>r.filter(s=>s.state==="FAILED")),v=i(u,r=>r.filter(s=>s.state==="PAUSED")),L=i(g,r=>r.stats),B=i(g,r=>r.loading);i(g,r=>r.error);function b(r){if(r===0)return"0 B";const s=1024,n=["B","KB","MB","GB","TB"],a=Math.floor(Math.log(r)/Math.log(s));return`${(r/Math.pow(s,a)).toFixed(2)} ${n[a]}`}function H(r){return`${b(r)}/s`}function I(r){if(!r||r<=0)return"--";const s=Math.floor(r/3600),n=Math.floor(r%3600/60),a=Math.floor(r%60);return s>0?`${s}h ${n}m`:n>0?`${n}m ${a}s`:`${a}s`}export{u as a,x as b,W as c,g as d,b as e,j as f,H as g,I as h,B as i,C as j,L as k,v as p,N as q,_ as s,w};
